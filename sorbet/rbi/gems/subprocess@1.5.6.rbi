# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `subprocess` gem.
# Please instead update this file by running `bin/tapioca gem subprocess`.

# typed: strong

# A Ruby clone of Python's subprocess module.
#
# @see http://docs.python.org/2/library/subprocess.html
#
# source://subprocess//lib/subprocess/version.rb#1
# THIS FILE IS AUTOGENERATED. DO NOT EDIT.
# To regenerate from YARD comments:
# bundle exec rake sord
module Subprocess
  class << self
    # Call and wait for the return of a given process.
    #
    # @note If you call this function with `:stdout => PIPE` or `:stderr => PIPE`,
    #   this function will block indefinitely as soon as the OS's pipe buffer
    #   fills up, as neither file descriptor will be read from. To avoid this, use
    #   {Process#communicate} from a passed block.
    # @param cmd [Array<String>] See {Process#initialize}
    # @param opts [Hash] See {Process#initialize}
    # @return [::Process::Status] The exit status of the process
    # @see Process#initialize
    # @yield [process] See {Process#initialize}
    # @yieldparam process [Process] See {Process#initialize}
    #
    # source://subprocess//lib/subprocess.rb#45
    def call(cmd, opts = T.unsafe(nil), &blk); end

    # Like {Subprocess::call}, except raise a {NonZeroExit} if the process did not
    # terminate successfully.
    #
    # @example Grep a file for a string
    #   Subprocess.check_call(%W{grep -q llama ~/favorite_animals})
    # @example Communicate with a child process
    #   Subprocess.check_call(%W{sendmail -t}, :stdin => Subprocess::PIPE) do |p|
    #   p.communicate <<-EMAIL
    #   From: alpaca@example.com
    #   To: llama@example.com
    #   Subject: I am so fluffy.
    #
    #   SO FLUFFY!
    #   http://upload.wikimedia.org/wikipedia/commons/3/3e/Unshorn_alpaca_grazing.jpg
    #   EMAIL
    #   end
    # @note If you call this function with `:stdout => PIPE` or `:stderr => PIPE`,
    #   this function will block indefinitely as soon as the OS's pipe buffer
    #   fills up, as neither file descriptor will be read from. To avoid this, use
    #   {Process#communicate} from a passed block.
    # @param cmd [Array<String>] See {Process#initialize}
    # @param opts [Hash] See {Process#initialize}
    # @raise [NonZeroExit] if the process returned a non-zero exit status (i.e.,
    #   was terminated with an error or was killed by a signal)
    # @return [::Process::Status] The exit status of the process
    # @see Process#initialize
    # @yield [process] See {Process#initialize}
    # @yieldparam process [Process] See {Process#initialize}
    #
    # source://subprocess//lib/subprocess.rb#82
    def check_call(cmd, opts = T.unsafe(nil), &blk); end

    # Like {Subprocess::check_call}, but return the contents of `stdout`, much
    # like {::Kernel#system}.
    #
    # @example Get the system load
    #   system_load = Subprocess.check_output(['uptime']).split(' ').last(3)
    # @param cmd [Array<String>] See {Process#initialize}
    # @param opts [Hash] See {Process#initialize}
    # @raise [NonZeroExit] if the process returned a non-zero exit status (i.e.,
    #   was terminated with an error or was killed by a signal)
    # @return [String] The contents of `stdout`
    # @see Process#initialize
    # @yield [process] See {Process#initialize}
    # @yieldparam process [Process] See {Process#initialize}
    #
    # source://subprocess//lib/subprocess.rb#104
    def check_output(cmd, opts = T.unsafe(nil), &blk); end

    # An alias for `Process.new`. Mostly here to better emulate the Python API.
    #
    # @param cmd [Array<String>] See {Process#initialize}
    # @param opts [Hash] See {Process#initialize}
    # @return [Process] A process with the given arguments
    # @see Process#initialize
    # @yield [process] See {Process#initialize}
    # @yieldparam process [Process] See {Process#initialize}
    #
    # source://subprocess//lib/subprocess.rb#26
    def popen(cmd, opts = T.unsafe(nil), &blk); end

    # Print a human readable interpretation of a process exit status.
    #
    # @param status [::Process::Status] The status returned by `waitpid2`.
    # @param convert_high_exit [Boolean] Whether to convert exit statuses greater
    #   than 128 into the usual convention for exiting after trapping a signal.
    #   (e.g. many programs will exit with status 130 after receiving a SIGINT /
    #   signal 2.)
    # @return [String] Text interpretation
    #
    # source://subprocess//lib/subprocess.rb#121
    def status_to_s(status, convert_high_exit = T.unsafe(nil)); end
  end
end

# Error class representing a timeout during a call to `communicate`
#
# source://subprocess//lib/subprocess.rb#188
class Subprocess::CommunicateTimeout < ::StandardError
  # @param cmd [Array<String>]
  # @param stdout [String]
  # @param stderr [String]
  # @return [CommunicateTimeout] a new instance of CommunicateTimeout
  #
  # source://subprocess//lib/subprocess.rb#197
  def initialize(cmd, stdout, stderr); end

  # @return [String] Content read from stderr before the timeout
  #
  # source://subprocess//lib/subprocess.rb#192
  def stderr; end

  # @return [String] Content read from stdout before the timeout
  #
  # source://subprocess//lib/subprocess.rb#189
  def stdout; end
end

# Error class representing a process's abnormal exit.
#
# source://subprocess//lib/subprocess.rb#160
class Subprocess::NonZeroExit < ::StandardError
  # Return an instance of {NonZeroExit}.
  #
  # @param cmd [Array<String>] The command that returned a non-zero status.
  # @param status [::Process::Status] The status returned by `waitpid`.
  # @return [NonZeroExit] a new instance of NonZeroExit
  #
  # source://subprocess//lib/subprocess.rb#170
  def initialize(cmd, status); end

  # @note This is intended only for use in user-facing error messages. In
  #   particular, no shell quoting of any sort is performed when
  #   constructing this string, meaning that blindly running it in a shell
  #   might have different semantics than the original command.
  # @return [String] The command and arguments for the process that exited
  #   abnormally.
  #
  # source://subprocess//lib/subprocess.rb#161
  def command; end

  # @return [::Process::Status] The Ruby status object returned by `waitpid`
  #
  # source://subprocess//lib/subprocess.rb#164
  def status; end
end

# An opaque constant that indicates that a pipe should be opened.
#
# source://subprocess//lib/subprocess.rb#12
Subprocess::PIPE = T.let(T.unsafe(nil), Integer)

# A child process. The preferred way of spawning a subprocess is through the
# functions on {Subprocess} (especially {Subprocess::check_call} and
# {Subprocess::check_output}).
#
# source://subprocess//lib/subprocess.rb#208
# A child process. The preferred way of spawning a subprocess is through the
# functions on {Subprocess} (especially {Subprocess::check_call} and
class Subprocess::Process
  # Create a new process.
  #
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @param cmd [Array<String>] The command to run and its arguments (in the
  #   style of an `argv` array). Unlike Python's subprocess module, `cmd`
  #   cannot be a String.
  # @param opts [Hash] a customizable set of options
  # @raise [ArgumentError]
  # @return [Process] a new instance of Process
  # @yield [process] Yields the just-spawned {Process} to the optional block.
  #   This occurs after all of {Process}'s error handling has been completed,
  #   and is a great place to call {Process#communicate}, especially when used
  #   in conjunction with {Subprocess::check_call}.
  # @yieldparam process [Process] The process that was just spawned.
  #
  # source://subprocess//lib/subprocess.rb#268
  def initialize(cmd, opts = T.unsafe(nil), &blk); end

  # @return [Array<String>] The command this process was invoked with.
  #
  # source://subprocess//lib/subprocess.rb#219
  def command; end

  # Write the (optional) input to the process's `stdin` and read the contents of
  # `stdout` and `stderr`. If a block is provided, stdout and stderr are yielded as they
  # are read. Otherwise they are buffered in memory and returned when the process
  # exits. Do this all using `IO::select`, so we don't deadlock due to full pipe
  # buffers.
  #
  # This is only really useful if you set some of `:stdin`, `:stdout`, and
  # `:stderr` to {Subprocess::PIPE}.
  #
  # @param input [String] A string to feed to the child's standard input.
  # @param timeout_s [Numeric] Raise {Subprocess::CommunicateTimeout} if communicate
  #   does not finish after timeout_s seconds.
  # @raise [ArgumentError]
  # @return [Array(String, String), nil] An array of two elements: the data read from the
  #   child's standard output and standard error, respectively.
  #   Returns nil if a block is provided.
  # @yieldparam stdout [String] Data read from stdout since the last yield
  # @yieldparam stderr [String] Data read from stderr since the last yield
  #
  # source://subprocess//lib/subprocess.rb#428
  def communicate(input = T.unsafe(nil), timeout_s = T.unsafe(nil)); end

  # Do nonblocking reads from `fd`, appending all data read into `buf`.
  #
  # @param fd [IO] The file to read from.
  # @param buf [String] A buffer to append the read data to.
  # @return [true, false] Whether `fd` was closed due to an exceptional
  #   condition (`EOFError` or `EPIPE`).
  #
  # source://subprocess//lib/subprocess.rb#398
  def drain_fd(fd, buf = T.unsafe(nil)); end

  # @return [Integer] The process ID of the spawned process.
  #
  # source://subprocess//lib/subprocess.rb#222
  def pid; end

  # Poll the child, setting (and returning) its status. If the child has not
  # terminated, return nil and exit immediately
  #
  # @return [::Process::Status, nil] The exit status of the process
  #
  # source://subprocess//lib/subprocess.rb#379
  # Poll the child, setting (and returning) its status. If the child has not
  # _@return_ — The exit status of the process
  sig { returns(T.nilable(::Process::Status)) }
  def poll; end

  # Does exactly what it says on the box.
  #
  # @param signal [String, Symbol, Integer] The signal to send to the child
  #   process. Accepts all the same arguments as Ruby's built-in
  #   {::Process::kill}, for instance a string like "INT" or "SIGINT", or a
  #   signal number like 2.
  # @return [Integer] See {::Process.kill}
  # @see ::Process.kill
  #
  # source://subprocess//lib/subprocess.rb#535
  def send_signal(signal); end

  # @return [::Process::Status, nil] The exit status code of the process.
  #   Only set after the process has exited.
  #
  # source://subprocess//lib/subprocess.rb#226
  def status; end

  # @return [IO] The `IO` that is connected to this process's `stderr`.
  #
  # source://subprocess//lib/subprocess.rb#216
  def stderr; end

  # @return [IO] The `IO` that is connected to this process's `stdin`.
  #
  # source://subprocess//lib/subprocess.rb#210
  def stdin; end

  # @return [IO] The `IO` that is connected to this process's `stdout`.
  #
  # source://subprocess//lib/subprocess.rb#213
  def stdout; end

  # Sends `SIGTERM` to the process.
  #
  # @return [Integer] See {send_signal}
  # @see send_signal
  #
  # source://subprocess//lib/subprocess.rb#544
  # _@return_ — See {send_signal}
  # _@see_ `send_signal`
  sig { returns(Integer) }
  def terminate; end

  # Wait for the child to return, setting and returning the status of the
  # child.
  #
  # @return [::Process::Status] The exit status of the process
  #
  # source://subprocess//lib/subprocess.rb#387
  # Wait for the child to return, setting and returning the status of the
  # _@return_ — The exit status of the process
  sig { returns(::Process::Status) }
  def wait; end

  private

  # The pair to parse_fd, returns whether or not the file descriptor was
  # opened by us (and therefore should be closed by us).
  #
  # @param fd [IO, Integer, String, nil]
  # @return [Boolean]
  #
  # source://subprocess//lib/subprocess.rb#581
  def our_fd?(fd); end

  # Return a pair of values (child, mine), which are how the given file
  # descriptor should appear to the child and to this process, respectively.
  # "mine" is only non-nil in the case of a pipe (in fact, we just return a
  # list of length one, since ruby will unpack nils from missing list items).
  #
  # @param fd [IO, Integer, String, nil]
  # @param mode [String]
  # @return [Array<IO>]
  #
  # source://subprocess//lib/subprocess.rb#557
  def parse_fd(fd, mode); end

  # Call IO.select timing out at Time `timeout_at`. If `timeout_at` is nil, never times out.
  #
  # @param read_array [Array<IO>, nil]
  # @param write_array [Array<IO>, nil]
  # @param err_array [Array<IO>, nil]
  # @param timeout_at [Integer, Float, nil]
  # @return [Array<Array<IO>>, nil]
  #
  # source://subprocess//lib/subprocess.rb#597
  def select_until(read_array, write_array, err_array, timeout_at); end

  class << self
    # @param pid [Integer]
    # @return [void]
    #
    # source://subprocess//lib/subprocess.rb#687
    def catching_sigchld(pid); end

    # @return [void]
    #
    # source://subprocess//lib/subprocess.rb#616
    sig { void }
    def handle_sigchld; end

    # @param pid [Integer]
    # @param fd [IO]
    # @return [void]
    #
    # source://subprocess//lib/subprocess.rb#657
    def register_pid(pid, fd); end

    # @param pid [Integer]
    # @return [void]
    #
    # source://subprocess//lib/subprocess.rb#676
    def unregister_pid(pid); end

    # Wake up everyone. We can't tell who we should wake up without `wait`ing,
    # and we want to let the process itself do that. In practice, we're not
    # likely to have that many in-flight subprocesses, so this is probably not a
    # big deal.
    #
    # @return [void]
    #
    # source://subprocess//lib/subprocess.rb#639
    # Wake up everyone. We can't tell who we should wake up without `wait`ing,
    # and we want to let the process itself do that. In practice, we're not
    # likely to have that many in-flight subprocesses, so this is probably not a
    sig { void }
    def wakeup_sigchld; end
  end
end

# An opaque constant that can be passed to the `:stderr` option that indicates
# that the standard error stream should be redirected to the standard output.
#
# source://subprocess//lib/subprocess.rb#15
Subprocess::STDOUT = T.let(T.unsafe(nil), Integer)

# source://subprocess//lib/subprocess/version.rb#2
Subprocess::VERSION = T.let(T.unsafe(nil), String)
