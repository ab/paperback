# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rqrcode` gem.
# Please instead update this file by running `bin/tapioca gem rqrcode`.

# source://rqrcode//lib/rqrcode/core_ext/array.rb#3
class Array
  include ::Enumerable
  include ::RQRCode::CoreExtensions::Array::Behavior
end

# source://rqrcode//lib/rqrcode/core_ext/integer.rb#3
class Integer < ::Numeric
  include ::RQRCode::CoreExtensions::Integer::Bitwise
end

# source://rqrcode//lib/rqrcode/core_ext/array/behavior.rb#1
module RQRCode; end

# source://rqrcode//lib/rqrcode/qrcode/qr_alphanumeric.rb#3
RQRCode::ALPHANUMERIC = T.let(T.unsafe(nil), Array)

# source://rqrcode//lib/rqrcode/core_ext/array/behavior.rb#2
module RQRCode::CoreExtensions; end

# source://rqrcode//lib/rqrcode/core_ext/array/behavior.rb#3
module RQRCode::CoreExtensions::Array; end

# source://rqrcode//lib/rqrcode/core_ext/array/behavior.rb#4
module RQRCode::CoreExtensions::Array::Behavior
  # source://rqrcode//lib/rqrcode/core_ext/array/behavior.rb#5
  def extract_options!; end
end

# source://rqrcode//lib/rqrcode/core_ext/integer/bitwise.rb#3
module RQRCode::CoreExtensions::Integer; end

# source://rqrcode//lib/rqrcode/core_ext/integer/bitwise.rb#4
module RQRCode::CoreExtensions::Integer::Bitwise
  # source://rqrcode//lib/rqrcode/core_ext/integer/bitwise.rb#5
  def rszf(count); end
end

# source://rqrcode//lib/rqrcode/export/png.rb#6
module RQRCode::Export; end

# source://rqrcode//lib/rqrcode/export/ansi.rb#3
module RQRCode::Export::ANSI
  # Returns a string of the QR code as
  # characters writen with ANSI background set.
  #
  # Options:
  # light: Foreground ("\033[47m")
  # dark: Background ANSI code. ("\033[47m")
  # fill_character: The written character. ('  ')
  # quiet_zone_size: (4)
  #
  # source://rqrcode//lib/rqrcode/export/ansi.rb#14
  def as_ansi(options = T.unsafe(nil)); end
end

# source://rqrcode//lib/rqrcode/export/html.rb#4
module RQRCode::Export::HTML
  # source://rqrcode//lib/rqrcode/export/html.rb#6
  def as_html; end

  private

  # source://rqrcode//lib/rqrcode/export/html.rb#12
  def rows; end
end

# source://rqrcode//lib/rqrcode/export/html.rb#36
class RQRCode::Export::HTML::Cell < ::Struct
  # source://rqrcode//lib/rqrcode/export/html.rb#37
  def as_html; end

  # @return [Boolean]
  #
  # source://rqrcode//lib/rqrcode/export/html.rb#45
  def dark?; end

  # source://rqrcode//lib/rqrcode/export/html.rb#41
  def html_class; end
end

# source://rqrcode//lib/rqrcode/export/html.rb#26
class RQRCode::Export::HTML::Row < ::Struct
  # source://rqrcode//lib/rqrcode/export/html.rb#27
  def as_html; end

  # source://rqrcode//lib/rqrcode/export/html.rb#31
  def cells; end
end

# source://rqrcode//lib/rqrcode/export/html.rb#16
class RQRCode::Export::HTML::Rows < ::Struct
  # source://rqrcode//lib/rqrcode/export/html.rb#17
  def as_html; end

  # source://rqrcode//lib/rqrcode/export/html.rb#21
  def rows; end
end

# source://rqrcode//lib/rqrcode/export/png.rb#7
module RQRCode::Export::PNG
  # Render the PNG from the Qrcode.
  #
  # There are two sizing algoritams.
  #
  # - Original that can result in blurry and hard to scan images
  # - Google's Chart API inspired sizing that resizes the module size to fit within the given image size.
  #
  # The Googleis one will be used when no options are given or when the new size option is used.
  #
  # Options:
  # fill  - Background ChunkyPNG::Color, defaults to 'white'
  # color - Foreground ChunkyPNG::Color, defaults to 'black'
  #
  # *Googleis*
  # size            - Total size of PNG in pixels. The module size is calculated so it fits. (defaults to 90)
  # border_modules  - Width of white border around in modules. (defaults to 4).
  #
  #  -- DONT USE border_modules OPTION UNLESS YOU KNOW ABOUT THE QUIET ZONE NEEDS OF QR CODES --
  #
  # *Original*
  # module_px_size  - Image size, in pixels.
  # border - Border thickness, in pixels
  #
  # It first creates an image where 1px = 1 module, then resizes.
  # Defaults to 90x90 pixels, customizable by option.
  #
  # source://rqrcode//lib/rqrcode/export/png.rb#35
  def as_png(options = T.unsafe(nil)); end
end

# source://rqrcode//lib/rqrcode/export/svg.rb#6
module RQRCode::Export::SVG
  # Render the SVG from the Qrcode.
  #
  # Options:
  # offset - Padding around the QR Code (e.g. 10)
  # fill - Background color (e.g "ffffff" or :white)
  # color - Foreground color for the code (e.g. "000000" or :black)
  # module_size - The Pixel size of each module (e.g. 11)
  # shape_rendering - Defaults to crispEdges
  #
  # source://rqrcode//lib/rqrcode/export/svg.rb#17
  def as_svg(options = T.unsafe(nil)); end
end

# source://rqrcode//lib/rqrcode/qrcode/qr_numeric.rb#3
RQRCode::NUMERIC = T.let(T.unsafe(nil), Array)

# source://rqrcode//lib/rqrcode/qrcode/qr_8bit_byte.rb#14
class RQRCode::QR8bitByte
  # @return [QR8bitByte] a new instance of QR8bitByte
  #
  # source://rqrcode//lib/rqrcode/qrcode/qr_8bit_byte.rb#17
  def initialize(data); end

  # source://rqrcode//lib/rqrcode/qrcode/qr_8bit_byte.rb#23
  def get_length; end

  # Returns the value of attribute mode.
  #
  # source://rqrcode//lib/rqrcode/qrcode/qr_8bit_byte.rb#15
  def mode; end

  # source://rqrcode//lib/rqrcode/qrcode/qr_8bit_byte.rb#28
  def write(buffer); end
end

# source://rqrcode//lib/rqrcode/qrcode/qr_alphanumeric.rb#5
class RQRCode::QRAlphanumeric
  # @raise [QRCodeArgumentError]
  # @return [QRAlphanumeric] a new instance of QRAlphanumeric
  #
  # source://rqrcode//lib/rqrcode/qrcode/qr_alphanumeric.rb#8
  def initialize(data); end

  # source://rqrcode//lib/rqrcode/qrcode/qr_alphanumeric.rb#17
  def get_length; end

  # Returns the value of attribute mode.
  #
  # source://rqrcode//lib/rqrcode/qrcode/qr_alphanumeric.rb#6
  def mode; end

  # source://rqrcode//lib/rqrcode/qrcode/qr_alphanumeric.rb#29
  def write(buffer); end

  class << self
    # @return [Boolean]
    #
    # source://rqrcode//lib/rqrcode/qrcode/qr_alphanumeric.rb#21
    def valid_data?(data); end
  end
end

# source://rqrcode//lib/rqrcode/qrcode/qr_bit_buffer.rb#14
class RQRCode::QRBitBuffer
  # @return [QRBitBuffer] a new instance of QRBitBuffer
  #
  # source://rqrcode//lib/rqrcode/qrcode/qr_bit_buffer.rb#20
  def initialize(version); end

  # source://rqrcode//lib/rqrcode/qrcode/qr_bit_buffer.rb#65
  def alphanumeric_encoding_start(length); end

  # Returns the value of attribute buffer.
  #
  # source://rqrcode//lib/rqrcode/qrcode/qr_bit_buffer.rb#15
  def buffer; end

  # source://rqrcode//lib/rqrcode/qrcode/qr_bit_buffer.rb#58
  def byte_encoding_start(length); end

  # source://rqrcode//lib/rqrcode/qrcode/qr_bit_buffer.rb#92
  def end_of_message(max_data_bits); end

  # source://rqrcode//lib/rqrcode/qrcode/qr_bit_buffer.rb#27
  def get(index); end

  # source://rqrcode//lib/rqrcode/qrcode/qr_bit_buffer.rb#40
  def get_length_in_bits; end

  # source://rqrcode//lib/rqrcode/qrcode/qr_bit_buffer.rb#72
  def numeric_encoding_start(length); end

  # source://rqrcode//lib/rqrcode/qrcode/qr_bit_buffer.rb#79
  def pad_until(prefered_size); end

  # source://rqrcode//lib/rqrcode/qrcode/qr_bit_buffer.rb#33
  def put(num, length); end

  # source://rqrcode//lib/rqrcode/qrcode/qr_bit_buffer.rb#45
  def put_bit(bit); end
end

# source://rqrcode//lib/rqrcode/qrcode/qr_bit_buffer.rb#17
RQRCode::QRBitBuffer::PAD0 = T.let(T.unsafe(nil), Integer)

# source://rqrcode//lib/rqrcode/qrcode/qr_bit_buffer.rb#18
RQRCode::QRBitBuffer::PAD1 = T.let(T.unsafe(nil), Integer)

# == Creation
#
# QRCode objects expect only one required constructor parameter
# and an optional hash of any other. Here's a few examples:
#
#  qr = RQRCode::QRCode.new('hello world')
#  qr = RQRCode::QRCode.new('hello world', :size => 1, :level => :m, :mode => :alphanumeric )
#
# source://rqrcode//lib/rqrcode/qrcode/qr_code.rb#164
class RQRCode::QRCode
  include ::RQRCode::Export::PNG
  include ::RQRCode::Export::SVG
  include ::RQRCode::Export::HTML
  include ::RQRCode::Export::ANSI

  # Expects a string to be parsed in, other args are optional
  #
  #   # string - the string you wish to encode
  #   # size   - the size of the qrcode (default 4)
  #   # level  - the error correction level, can be:
  #      * Level :l 7%  of code can be restored
  #      * Level :m 15% of code can be restored
  #      * Level :q 25% of code can be restored
  #      * Level :h 30% of code can be restored (default :h)
  #   # mode   - the mode of the qrcode (defaults to alphanumeric or byte_8bit, depending on the input data):
  #      * :number
  #      * :alphanumeric
  #      * :byte_8bit
  #      * :kanji
  #
  #   qr = RQRCode::QRCode.new('hello world', :size => 1, :level => :m, :mode => :alphanumeric )
  #
  # @return [QRCode] a new instance of QRCode
  #
  # source://rqrcode//lib/rqrcode/qrcode/qr_code.rb#185
  def initialize(string, *args); end

  # <tt>is_dark</tt> is called with a +col+ and +row+ parameter. This will
  # return true or false based on whether that coordinate exists in the
  # matrix returned. It would normally be called while iterating through
  # <tt>modules</tt>. A simple example would be:
  #
  #  instance.is_dark( 10, 10 ) => true
  #
  # source://rqrcode//lib/rqrcode/qrcode/qr_code.rb#243
  def dark?(row, col); end

  # Return a symbol for current error connection level
  #
  # source://rqrcode//lib/rqrcode/qrcode/qr_code.rb#293
  def error_correction_level; end

  # <tt>is_dark</tt> is called with a +col+ and +row+ parameter. This will
  # return true or false based on whether that coordinate exists in the
  # matrix returned. It would normally be called while iterating through
  # <tt>modules</tt>. A simple example would be:
  #
  #  instance.is_dark( 10, 10 ) => true
  #
  # source://rqrcode//lib/rqrcode/qrcode/qr_code.rb#243
  def is_dark(row, col); end

  # Return a symbol in QRMODE.keys for current mode used
  #
  # source://rqrcode//lib/rqrcode/qrcode/qr_code.rb#298
  def mode; end

  # Returns the value of attribute module_count.
  #
  # source://rqrcode//lib/rqrcode/qrcode/qr_code.rb#165
  def module_count; end

  # Returns the value of attribute modules.
  #
  # source://rqrcode//lib/rqrcode/qrcode/qr_code.rb#165
  def modules; end

  # This is a public method that returns the QR Code you have
  # generated as a string. It will not be able to be read
  # in this format by a QR Code reader, but will give you an
  # idea if the final outout. It takes two optional args
  # +:true+ and +:false+ which are there for you to choose
  # how the output looks. Here's an example of it's use:
  #
  #  instance.to_s =>
  #  xxxxxxx x  x x   x x  xx  xxxxxxx
  #  x     x  xxx  xxxxxx xxx  x     x
  #  x xxx x  xxxxx x       xx x xxx x
  #
  #  instance._to_s( :dark => 'E', :light => 'Q') =>
  #  EEEEEEEQEQQEQEQQQEQEQQEEQQEEEEEEE
  #  EQQQQQEQQEEEQQEEEEEEQEEEQQEQQQQQE
  #  EQEEEQEQQEEEEEQEQQQQQQQEEQEQEEEQE
  #
  # source://rqrcode//lib/rqrcode/qrcode/qr_code.rb#269
  def to_s(*args); end

  # Returns the value of attribute version.
  #
  # source://rqrcode//lib/rqrcode/qrcode/qr_code.rb#165
  def version; end

  protected

  # source://rqrcode//lib/rqrcode/qrcode/qr_code.rb#311
  def make; end

  private

  # source://rqrcode//lib/rqrcode/qrcode/qr_code.rb#364
  def get_best_mask_pattern; end

  # source://rqrcode//lib/rqrcode/qrcode/qr_code.rb#330
  def make_impl(test, mask_pattern); end

  # source://rqrcode//lib/rqrcode/qrcode/qr_code.rb#450
  def map_data(data, mask_pattern); end

  # source://rqrcode//lib/rqrcode/qrcode/qr_code.rb#417
  def place_format_info(test, mask_pattern); end

  # source://rqrcode//lib/rqrcode/qrcode/qr_code.rb#388
  def place_position_adjust_pattern; end

  # source://rqrcode//lib/rqrcode/qrcode/qr_code.rb#346
  def place_position_probe_pattern(row, col); end

  # source://rqrcode//lib/rqrcode/qrcode/qr_code.rb#381
  def place_timing_pattern; end

  # source://rqrcode//lib/rqrcode/qrcode/qr_code.rb#406
  def place_version_info(test); end

  # source://rqrcode//lib/rqrcode/qrcode/qr_code.rb#318
  def prepare_common_patterns; end

  # @raise [QRCodeRunTimeError]
  #
  # source://rqrcode//lib/rqrcode/qrcode/qr_code.rb#490
  def smallest_size_for(string, max_size_array); end

  class << self
    # source://rqrcode//lib/rqrcode/qrcode/qr_code.rb#497
    def count_max_data_bits(rs_blocks); end

    # source://rqrcode//lib/rqrcode/qrcode/qr_code.rb#523
    def create_bytes(buffer, rs_blocks); end

    # source://rqrcode//lib/rqrcode/qrcode/qr_code.rb#505
    def create_data(version, error_correct_level, data_list); end
  end
end

# StandardErrors
#
# source://rqrcode//lib/rqrcode/qrcode/qr_code.rb#152
class RQRCode::QRCodeArgumentError < ::ArgumentError; end

# source://rqrcode//lib/rqrcode/qrcode/qr_code.rb#153
class RQRCode::QRCodeRunTimeError < ::RuntimeError; end

# source://rqrcode//lib/rqrcode/qrcode/qr_code.rb#26
RQRCode::QRERRORCORRECTLEVEL = T.let(T.unsafe(nil), Hash)

# source://rqrcode//lib/rqrcode/qrcode/qr_code.rb#58
RQRCode::QRFORMATINFOLENGTH = T.let(T.unsafe(nil), Integer)

# source://rqrcode//lib/rqrcode/qrcode/qr_code.rb#44
RQRCode::QRMASKCOMPUTATIONS = T.let(T.unsafe(nil), Array)

# source://rqrcode//lib/rqrcode/qrcode/qr_code.rb#33
RQRCode::QRMASKPATTERN = T.let(T.unsafe(nil), Hash)

# http://web.archive.org/web/20110710094955/http://www.denso-wave.com/qrcode/vertable1-e.html
# http://web.archive.org/web/20110710094955/http://www.denso-wave.com/qrcode/vertable2-e.html
# http://web.archive.org/web/20110710094955/http://www.denso-wave.com/qrcode/vertable3-e.html
# http://web.archive.org/web/20110710094955/http://www.denso-wave.com/qrcode/vertable4-e.html
# Each array contains levels max chars from level 1 to level 40
#
# source://rqrcode//lib/rqrcode/qrcode/qr_code.rb#65
RQRCode::QRMAXDIGITS = T.let(T.unsafe(nil), Hash)

# source://rqrcode//lib/rqrcode/qrcode/qr_code.rb#14
RQRCode::QRMODE = T.let(T.unsafe(nil), Hash)

# source://rqrcode//lib/rqrcode/qrcode/qr_code.rb#20
RQRCode::QRMODE_NAME = T.let(T.unsafe(nil), Hash)

# source://rqrcode//lib/rqrcode/qrcode/qr_math.rb#14
class RQRCode::QRMath
  class << self
    # source://rqrcode//lib/rqrcode/qrcode/qr_math.rb#47
    def gexp(n); end

    # @raise [QRCodeRunTimeError]
    #
    # source://rqrcode//lib/rqrcode/qrcode/qr_math.rb#41
    def glog(n); end
  end
end

# source://rqrcode//lib/rqrcode/qrcode/qr_math.rb#35
RQRCode::QRMath::EXP_TABLE = T.let(T.unsafe(nil), Array)

# source://rqrcode//lib/rqrcode/qrcode/qr_math.rb#36
RQRCode::QRMath::LOG_TABLE = T.let(T.unsafe(nil), Array)

# source://rqrcode//lib/rqrcode/qrcode/qr_numeric.rb#5
class RQRCode::QRNumeric
  # @raise [QRCodeArgumentError]
  # @return [QRNumeric] a new instance of QRNumeric
  #
  # source://rqrcode//lib/rqrcode/qrcode/qr_numeric.rb#8
  def initialize(data); end

  # source://rqrcode//lib/rqrcode/qrcode/qr_numeric.rb#17
  def get_length; end

  # Returns the value of attribute mode.
  #
  # source://rqrcode//lib/rqrcode/qrcode/qr_numeric.rb#6
  def mode; end

  # source://rqrcode//lib/rqrcode/qrcode/qr_numeric.rb#29
  def write(buffer); end

  private

  # source://rqrcode//lib/rqrcode/qrcode/qr_numeric.rb#49
  def get_bit_length(length); end

  # source://rqrcode//lib/rqrcode/qrcode/qr_numeric.rb#53
  def get_code(chars); end

  class << self
    # @return [Boolean]
    #
    # source://rqrcode//lib/rqrcode/qrcode/qr_numeric.rb#21
    def valid_data?(data); end
  end
end

# source://rqrcode//lib/rqrcode/qrcode/qr_numeric.rb#43
RQRCode::QRNumeric::NUMBER_LENGTH = T.let(T.unsafe(nil), Hash)

# source://rqrcode//lib/rqrcode/qrcode/qr_code.rb#57
RQRCode::QRPOSITIONPATTERNLENGTH = T.let(T.unsafe(nil), Integer)

# source://rqrcode//lib/rqrcode/qrcode/qr_polynomial.rb#14
class RQRCode::QRPolynomial
  # @raise [QRCodeRunTimeError]
  # @return [QRPolynomial] a new instance of QRPolynomial
  #
  # source://rqrcode//lib/rqrcode/qrcode/qr_polynomial.rb#16
  def initialize(num, shift); end

  # source://rqrcode//lib/rqrcode/qrcode/qr_polynomial.rb#32
  def get(index); end

  # source://rqrcode//lib/rqrcode/qrcode/qr_polynomial.rb#37
  def get_length; end

  # source://rqrcode//lib/rqrcode/qrcode/qr_polynomial.rb#56
  def mod(e); end

  # source://rqrcode//lib/rqrcode/qrcode/qr_polynomial.rb#42
  def multiply(e); end
end

# source://rqrcode//lib/rqrcode/qrcode/qr_rs_block.rb#14
class RQRCode::QRRSBlock
  # @return [QRRSBlock] a new instance of QRRSBlock
  #
  # source://rqrcode//lib/rqrcode/qrcode/qr_rs_block.rb#17
  def initialize(total_count, data_count); end

  # Returns the value of attribute data_count.
  #
  # source://rqrcode//lib/rqrcode/qrcode/qr_rs_block.rb#15
  def data_count; end

  # Returns the value of attribute total_count.
  #
  # source://rqrcode//lib/rqrcode/qrcode/qr_rs_block.rb#15
  def total_count; end

  class << self
    # source://rqrcode//lib/rqrcode/qrcode/qr_rs_block.rb#297
    def get_rs_block_table(version, error_correct_level); end

    # source://rqrcode//lib/rqrcode/qrcode/qr_rs_block.rb#272
    def get_rs_blocks(version, error_correct_level); end
  end
end

# http://www.thonky.com/qr-code-tutorial/error-correction-table/
#
# source://rqrcode//lib/rqrcode/qrcode/qr_rs_block.rb#23
RQRCode::QRRSBlock::RS_BLOCK_TABLE = T.let(T.unsafe(nil), Array)

# source://rqrcode//lib/rqrcode/qrcode/qr_util.rb#14
class RQRCode::QRUtil
  class << self
    # source://rqrcode//lib/rqrcode/qrcode/qr_util.rb#169
    def demerit_points_1_same_color(modules); end

    # source://rqrcode//lib/rqrcode/qrcode/qr_util.rb#200
    def demerit_points_2_full_blocks(modules); end

    # source://rqrcode//lib/rqrcode/qrcode/qr_util.rb#221
    def demerit_points_3_dangerous_patterns(modules); end

    # source://rqrcode//lib/rqrcode/qrcode/qr_util.rb#257
    def demerit_points_4_dark_ratio(modules); end

    # source://rqrcode//lib/rqrcode/qrcode/qr_util.rb#98
    def get_bch_digit(data); end

    # source://rqrcode//lib/rqrcode/qrcode/qr_util.rb#80
    def get_bch_format_info(data); end

    # source://rqrcode//lib/rqrcode/qrcode/qr_util.rb#89
    def get_bch_version(data); end

    # source://rqrcode//lib/rqrcode/qrcode/qr_util.rb#124
    def get_error_correct_polynomial(error_correct_length); end

    # source://rqrcode//lib/rqrcode/qrcode/qr_util.rb#135
    def get_length_in_bits(mode, version); end

    # source://rqrcode//lib/rqrcode/qrcode/qr_util.rb#158
    def get_lost_points(modules); end

    # source://rqrcode//lib/rqrcode/qrcode/qr_util.rb#115
    def get_mask(mask_pattern, i, j); end

    # source://rqrcode//lib/rqrcode/qrcode/qr_util.rb#110
    def get_pattern_positions(version); end

    # source://rqrcode//lib/rqrcode/qrcode/qr_util.rb#76
    def max_size; end
  end
end

# source://rqrcode//lib/rqrcode/qrcode/qr_util.rb#69
RQRCode::QRUtil::BITS_FOR_MODE = T.let(T.unsafe(nil), Hash)

# source://rqrcode//lib/rqrcode/qrcode/qr_util.rb#64
RQRCode::QRUtil::DEMERIT_POINTS_1 = T.let(T.unsafe(nil), Integer)

# source://rqrcode//lib/rqrcode/qrcode/qr_util.rb#65
RQRCode::QRUtil::DEMERIT_POINTS_2 = T.let(T.unsafe(nil), Integer)

# source://rqrcode//lib/rqrcode/qrcode/qr_util.rb#66
RQRCode::QRUtil::DEMERIT_POINTS_3 = T.let(T.unsafe(nil), Integer)

# source://rqrcode//lib/rqrcode/qrcode/qr_util.rb#67
RQRCode::QRUtil::DEMERIT_POINTS_4 = T.let(T.unsafe(nil), Integer)

# source://rqrcode//lib/rqrcode/qrcode/qr_util.rb#60
RQRCode::QRUtil::G15 = T.let(T.unsafe(nil), Integer)

# source://rqrcode//lib/rqrcode/qrcode/qr_util.rb#62
RQRCode::QRUtil::G15_MASK = T.let(T.unsafe(nil), Integer)

# source://rqrcode//lib/rqrcode/qrcode/qr_util.rb#61
RQRCode::QRUtil::G18 = T.let(T.unsafe(nil), Integer)

# source://rqrcode//lib/rqrcode/qrcode/qr_util.rb#16
RQRCode::QRUtil::PATTERN_POSITION_TABLE = T.let(T.unsafe(nil), Array)
