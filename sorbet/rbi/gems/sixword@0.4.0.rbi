# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `sixword` gem.
# Please instead update this file by running `bin/tapioca gem sixword`.

# Sixword, a binary encoder using the 6-word scheme from S/key standardized by
# RFC 2289, RFC 1760, and RFC 1751.
#
# All of the public methods are static methods on the Sixword module, for
# example {Sixword.encode} and {Sixword.decode}.
#
# The <tt>sixword</tt> command line interface and corresponding {Sixword::CLI}
# class is also very convenient for more complex use. It supports a variety of
# different styles for translating binary data and hexadecimal fingerprints.
#
# These hexadecimal methods are implemented in the {Sixword::Hex} module.
#
# source://sixword//lib/sixword/cli.rb#1
module Sixword
  class << self
    # Decode a six-word encoded string or string array.
    #
    # @example
    #   >> Sixword.decode("ACRE ADEN INN SLID MAD PAP")
    #   => "Hi world"
    # @example
    #   >> Sixword.decode("acre aden inn slid mad pap")
    #   => "Hi world"
    # @example
    #   Sixword.decode(%w{ACRE ADEN INN SLID MAD PAP})
    #   => "Hi world"
    # @example
    #   Sixword.decode([])
    #   => ""
    # @example
    #   Sixword.decode("COAT ACHE A A A ACT6", padding_ok: true)
    #   => "hi"
    # @option options
    # @param string_or_words [String, Array<String>] Either a String containing
    #   whitespace separated words or an Array of String words
    # @param options [Hash]
    # @raise InputError if the input is malformed or invalid in various ways
    # @return [String] A binary string of bytes
    #
    # source://sixword//lib/sixword.rb#238
    def decode(string_or_words, options = T.unsafe(nil)); end

    # Encode a string of bytes in six-word encoding. If you want to use the
    # custom padding scheme for inputs that are not a multiple of 8 in length,
    # use Sixword.pad_encode instead.
    #
    # @example
    #   >> Sixword.encode('Hi world')
    #   => ["ACRE", "ADEN", "INN", "SLID", "MAD", "PAP"]
    # @param byte_string [String] Length must be a multiple of 8
    # @raise Sixword::InputError
    # @return [Array<String>] an array of string words
    # @see Sixword.encode_iter
    #
    # source://sixword//lib/sixword.rb#48
    def encode(byte_string); end

    # Encode a string of bytes in six-word encoding (full API). This is the
    # relatively low level method that supports all the major options. See the
    # various other top-level methods for convenience helpers.
    #
    # @option options
    # @option options
    # @param byte_string [String] A byte string to encode
    # @param options [Hash]
    # @raise Sixword::InputError on incorrectly padded inputs
    # @raise ArgumentError on bad argument types
    # @return [Enumerator, nil] If no block is given, return an Enumerator
    # @yield [String] A String word (or String of space separated words, if
    #   :words_per_slice is given)
    #
    # source://sixword//lib/sixword.rb#159
    def encode_iter(byte_string, options = T.unsafe(nil)); end

    # Encode a string of bytes in six-word encoding. If you want to use the
    # custom padding scheme for inputs that are not a multiple of 8 in length,
    # use Sixword.pad_encode instead.
    #
    # @example
    #   >> Sixword.encode('Hi world')
    #   => ["ACRE", "ADEN", "INN", "SLID", "MAD", "PAP"]
    # @param byte_string [String] Length must be a multiple of 8
    # @raise Sixword::InputError
    # @return [Array<String>] an array of string words
    # @see Sixword.encode_iter
    #
    # source://sixword//lib/sixword.rb#48
    def encode_to_a(byte_string); end

    # Like {Sixword.encode}, but return a single string.
    #
    # @example
    #   Sixword.encode_to_s('Hi world' * 2)
    #   => "ACRE ADEN INN SLID MAD PAP ACRE ADEN INN SLID MAD PAP"
    # @param byte_string [String] Length must be a multiple of 8
    # @raise Sixword::InputError
    # @return [String] a string of words separated by spaces
    # @see Sixword.encode
    #
    # source://sixword//lib/sixword.rb#106
    def encode_to_s(byte_string); end

    # Like {Sixword.encode}, but return six words at a time (a complete block).
    #
    # @example
    #   Sixword.encode_to_sentences('Hi world' * 2)
    #   => ["ACRE ADEN INN SLID MAD PAP",
    #   "ACRE ADEN INN SLID MAD PAP"]
    # @param byte_string [String] Length must be a multiple of 8
    # @raise Sixword::InputError
    # @return [Array<String>] an array of 6-word string sentences
    # @see Sixword.encode
    #
    # source://sixword//lib/sixword.rb#89
    def encode_to_sentences(byte_string); end

    # Like {Sixword.decode}, but allow input to contain custom padding scheme.
    #
    # @example
    #   Sixword.decode("COAT ACHE A A A ACT6", padding_ok: true)
    #   => "hi"
    # @param string_or_words [String, Array<String>] Either a String containing
    #   whitespace separated words or an Array of String words
    # @raise InputError if the input is malformed or invalid in various ways
    # @return [String] A binary string of bytes
    # @see Sixword.decode
    #
    # source://sixword//lib/sixword.rb#276
    def pad_decode(string_or_words); end

    # Encode a string of bytes in six-word encoding, using the custom padding
    # scheme established by this library. The output will be identical to
    # {Sixword.encode} for strings that are a multiple of 8 in length.
    #
    # @example
    #   >> Sixword.encode('Hi wor')
    #   => ["ACRE", "ADEN", "INN", "SLID", "MAD", "PAP"]
    # @param byte_string [String] A string of any length
    # @return [Array<String>] an array of string words
    # @see Sixword.encode_iter
    #
    # source://sixword//lib/sixword.rb#65
    def pad_encode(byte_string); end

    # Encode a string of bytes in six-word encoding, using the custom padding
    # scheme established by this library. The output will be identical to
    # {Sixword.encode} for strings that are a multiple of 8 in length.
    #
    # @example
    #   >> Sixword.encode('Hi wor')
    #   => ["ACRE", "ADEN", "INN", "SLID", "MAD", "PAP"]
    # @param byte_string [String] A string of any length
    # @return [Array<String>] an array of string words
    # @see Sixword.encode_iter
    #
    # source://sixword//lib/sixword.rb#65
    def pad_encode_to_a(byte_string); end

    # Like {Sixword.encode_to_s}, but allow variable length input.
    #
    # @example
    #   >> Sixword.pad_encode_to_s('Hi worl' * 2)
    #   => "ACRE ADEN INN SLID MAD LEW CODY AS SIGH SUIT MUDD ABE2"
    # @param byte_string [String] A string of any length
    # @return [String] a string of words separated by spaces
    #
    # source://sixword//lib/sixword.rb#132
    def pad_encode_to_s(byte_string); end

    # Like {Sixword.encode_to_sentences}, but allow variable length input.
    #
    # @example
    #   >> Sixword.pad_encode_to_sentences('Hi worl' * 2)
    #   => ["ACRE ADEN INN SLID MAD LEW", "CODY AS SIGH SUIT MUDD ABE2"]
    # @param byte_string [String] A string of any length
    # @return [Array<String>] an array of 6-word string sentences
    #
    # source://sixword//lib/sixword.rb#119
    def pad_encode_to_sentences(byte_string); end
  end
end

# The Sixword::CLI class implements all of the complex processing needed for
# the sixword Command Line Interface.
#
# source://sixword//lib/sixword/cli.rb#5
class Sixword::CLI
  # Create a Sixword CLI to operate on filename with options
  #
  # @option options
  # @option options
  # @option options
  # @option options
  # @param filename [String] Input file name (or '-' for stdin)
  # @param options [Hash]
  # @return [CLI] a new instance of CLI
  #
  # source://sixword//lib/sixword/cli.rb#33
  def initialize(filename, options); end

  # Return true if we are in encoding mode, false otherwise (decoding).
  #
  # @return [Boolean]
  #
  # source://sixword//lib/sixword/cli.rb#61
  def encoding?; end

  # @return [String] Input filename
  #
  # source://sixword//lib/sixword/cli.rb#11
  def filename; end

  # Return the value of the :hex_style option.
  #
  # @return [String, nil]
  #
  # source://sixword//lib/sixword/cli.rb#67
  def hex_style; end

  # @return [:encode, :decode]
  #
  # source://sixword//lib/sixword/cli.rb#20
  def mode; end

  # @return [Hash] Options hash
  #
  # source://sixword//lib/sixword/cli.rb#14
  def options; end

  # Return the value of the :pad option.
  #
  # @return [Boolean]
  #
  # source://sixword//lib/sixword/cli.rb#55
  def pad?; end

  # Format data as hex in various styles.
  #
  # source://sixword//lib/sixword/cli.rb#72
  def print_hex(data, chunk_index, cols = T.unsafe(nil)); end

  # Run the encoding/decoding operation, printing the result to stdout.
  #
  # source://sixword//lib/sixword/cli.rb#96
  def run!; end

  # @return [File, IO] Stream opened from #filename
  #
  # source://sixword//lib/sixword/cli.rb#17
  def stream; end

  private

  # source://sixword//lib/sixword/cli.rb#213
  def accumulate_hex_input; end

  # source://sixword//lib/sixword/cli.rb#119
  def do_decode!; end

  # source://sixword//lib/sixword/cli.rb#129
  def do_encode!; end

  # source://sixword//lib/sixword/cli.rb#155
  def process_encode_input; end

  # Yield data 6 words at a time until EOF
  #
  # source://sixword//lib/sixword/cli.rb#187
  def read_input_by_6_words; end
end

# Exception for certain input validation errors
#
# source://sixword//lib/sixword/cli.rb#8
class Sixword::CLI::CLIError < ::StandardError; end

# Various hexadecimal string encoding and decoding functions
#
# source://sixword//lib/sixword/hex.rb#3
module Sixword::Hex
  class << self
    # Decode a hexadecimal string to a byte string.
    #
    # @param hex_string [String]
    # @param strip_chars [Boolean] Whether to accept and strip whitespace and
    #   other delimiters (see {HexStrip})
    # @raise ArgumentError on invalid hex input
    # @return [String]
    #
    # source://sixword//lib/sixword/hex.rb#94
    def decode(hex_string, strip_chars = T.unsafe(nil)); end

    # Encode a byte string as hexadecimal.
    #
    # @param bytes [String]
    # @return [String] hexadecimal string
    #
    # source://sixword//lib/sixword/hex.rb#34
    def encode(bytes); end

    # Encode a byte string in hex with colons: lowercase in slices of 2
    # separated by colons.
    #
    # @example
    #   >> encode_colons("9T]B\xF0\x039\xFF")
    #   => "39:54:5d:42:f0:03:39:ff"
    # @param bytes [String]
    # @return [String]
    #
    # source://sixword//lib/sixword/hex.rb#81
    def encode_colons(bytes); end

    # Encode a byte string as a GPG style fingerprint: uppercase in slices of 4
    # separated by spaces.
    #
    # @example
    #   >> encode_fingerprint("9T]B\xF0\x039\xFF")
    #   => "3954 5D42 F003 39FF"
    # @param bytes [String]
    # @return [String]
    #
    # source://sixword//lib/sixword/hex.rb#66
    def encode_fingerprint(bytes); end

    # Encode a byte string as hexadecimal, returning it in slices joined by a
    # delimiter. This is useful for generating colon or space separated strings
    # like those commonly used in fingerprints.
    #
    # @example
    #   >> encode_slice("9T]B\xF0\x039\xFF", 2, ':')
    #   => "39:54:5d:42:f0:03:39:ff"
    # @param bytes [String]
    # @param slice [Integer]
    # @param delimiter [String]
    # @return [String]
    #
    # source://sixword//lib/sixword/hex.rb#52
    def encode_slice(bytes, slice, delimiter); end

    # Return whether single character string is one of the fill characters that
    # are OK to strip from a hexadecimal string.
    #
    # @param char [String] String of length == 1
    # @return [Boolean]
    # @see [HexStrip]
    #
    # source://sixword//lib/sixword/hex.rb#22
    def strip_char?(char); end

    # Return whether string is entirely hexadecimal.
    #
    # @param string [String]
    # @return [Boolean]
    # @see [HexValid]
    #
    # source://sixword//lib/sixword/hex.rb#12
    def valid_hex?(string); end
  end
end

# source://sixword//lib/sixword/hex.rb#5
Sixword::Hex::HexStrip = T.let(T.unsafe(nil), Regexp)

# source://sixword//lib/sixword/hex.rb#4
Sixword::Hex::HexValid = T.let(T.unsafe(nil), Regexp)

# Parent class for inputs that could plausibly occur at runtime.
#
# source://sixword//lib/sixword.rb#22
class Sixword::InputError < ::ArgumentError; end

# Raised when the parity check fails
#
# source://sixword//lib/sixword.rb#25
class Sixword::InvalidParity < ::Sixword::InputError; end

# Raised in decoding when a word of invalid format is encountered
#
# source://sixword//lib/sixword.rb#31
class Sixword::InvalidWord < ::Sixword::InputError; end

# The Lib module contains various internal utility functions. They are not
# really part of the public API and will probably not be useful to external
# callers.
#
# source://sixword//lib/sixword/lib.rb#6
module Sixword::Lib
  class << self
    # Given an array of bytes, pack them into a single Integer.
    #
    # @example
    #
    #   >> byte_array_to_int([1, 2])
    #   => 258
    # @param byte_array [Array<Fixnum>]
    # @return [Integer]
    #
    # source://sixword//lib/sixword/lib.rb#218
    def byte_array_to_int(byte_array); end

    # Decode an array of 6 words into a 64-bit integer (representing 8 bytes).
    #
    # length of the byte array that it represents (will always be 8 unless
    # padding_ok)
    #
    # @example
    #   >> Sixword::Lib.decode_6_words(%w{COAT ACHE A A A ACT6}, true)
    #   => [26729, 2]
    #
    #   >> Sixword::Lib.decode_6_words(%w{ACRE ADEN INN SLID MAD PAP}, false)
    #   => [5217737340628397156, 8]
    # @param word_array [Array<String>] A 6 element array of String words
    # @param padding_ok [Boolean]
    # @return [Array(Integer, Integer)] a 64-bit integer (the data) and the
    #
    # source://sixword//lib/sixword/lib.rb#63
    def decode_6_words(word_array, padding_ok); end

    # Decode an array of 6 words into a String of bytes.
    #
    # @example
    #   >> Lib.decode_6_words_to_bstring(%w{COAT ACHE A A A ACT6}, true)
    #   => "hi"
    #
    #   >> Lib.decode_6_words_to_bstring(%w{ACRE ADEN INN SLID MAD PAP}, false)
    #   => "Hi world"
    # @param word_array [Array<String>] A 6 element array of String words
    # @param padding_ok [Boolean]
    # @return [String]
    # @see Sixword.decode_6_words
    # @see Sixword.int_to_byte_array
    #
    # source://sixword//lib/sixword/lib.rb#143
    def decode_6_words_to_bstring(word_array, padding_ok); end

    # Encode an array of 8 bytes as an array of 6 words.
    #
    # @example
    #   >> Sixword::Lib.encode_64_bits([0] * 8)
    #   => ["A", "A", "A", "A", "A", "A"]
    # @example
    #   >> Sixword::Lib.encode_64_bits([0xff] * 8)
    #   => ["YOKE", "YOKE", "YOKE", "YOKE", "YOKE", "YEAR"]
    # @param byte_array [Array<Fixnum>] An array of length 8 containing
    #   integers in 0..255
    # @return [Array<String>] An array of length 6 containing String words from
    #   {Sixword::WORDS}
    #
    # source://sixword//lib/sixword/lib.rb#24
    def encode_64_bits(byte_array); end

    # Extract the numeric padding from a word.
    #
    # @example
    #   >> Sixword::Lib.extract_padding("WORD3")
    #   => ["WORD", 3]
    # @param word [String]
    # @return [Array(String, Integer)] The String word, the Integer padding
    #
    # source://sixword//lib/sixword/lib.rb#118
    def extract_padding(word); end

    # Given an Integer, unpack it into an array of bytes.
    #
    # @example
    #   >> int_to_byte_array(258)
    #   => [1, 2]
    # @example
    #   >> int_to_byte_array(258, 3)
    #   => [0, 1, 2]
    # @param int [Integer]
    # @param length [Integer] Left zero padded size of byte array to return. If
    #   not provided, no leading zeroes will be added.
    # @return [Array<Fixnum>]
    #
    # source://sixword//lib/sixword/lib.rb#243
    def int_to_byte_array(int, length = T.unsafe(nil)); end

    # Compute two-bit parity on a byte array by summing each pair of bits.
    # TODO: figure out which is faster
    #
    # @param byte_array [Array<Fixnum>]
    # @return [Fixnum] An integer 0..3
    # @see parity_int
    #
    # source://sixword//lib/sixword/lib.rb#173
    def parity_array(byte_array); end

    # Compute two-bit parity on a 64-bit integer representing an 8-byte array
    # by summing each pair of bits.
    # TODO: figure out which is faster
    #
    # @param int [Integer] A 64-bit integer representing 8 bytes
    # @return [Fixnum] An integer 0..3
    # @see parity_array
    #
    # source://sixword//lib/sixword/lib.rb#197
    def parity_int(int); end

    # Given a word, return the 11 bits it represents as an integer (i.e. its
    # index in the WORDS list).
    #
    # @param word [String]
    # @return [Fixnum] An integer 0..2047
    #
    # source://sixword//lib/sixword/lib.rb#154
    def word_to_bits(word); end
  end
end

# Raised in decoding when an unrecognized word is encountered
#
# source://sixword//lib/sixword.rb#28
class Sixword::UnknownWord < ::Sixword::InputError; end

# version string
#
# source://sixword//lib/sixword/version.rb#3
Sixword::VERSION = T.let(T.unsafe(nil), String)

# Dictionary from RFC 2289 Appendix D
# http://tools.ietf.org/html/rfc2289#appendix-D
#
# source://sixword//lib/sixword/words.rb#5
Sixword::WORDS = T.let(T.unsafe(nil), Array)

# A mapping from Word => Integer index in the word list
#
# source://sixword//lib/sixword/words.rb#264
Sixword::WORDS_HASH = T.let(T.unsafe(nil), Hash)
