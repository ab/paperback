# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/ttfunk/all/ttfunk.rbi
#
# ttfunk-1.4.0
module TTFunk
end
class TTFunk::Directory
  def initialize(io); end
  def scaler_type; end
  def tables; end
end
class TTFunk::ResourceFile
  def [](type, index = nil); end
  def initialize(io); end
  def map; end
  def parse_from(offset); end
  def resources_for(type); end
  def self.open(path); end
end
module TTFunk::Reader
  def hexdump(string); end
  def io; end
  def parse_from(position); end
  def read(bytes, format); end
  def read_signed(count); end
  def to_signed(n); end
end
module TTFunk::Encoding
end
class TTFunk::Encoding::MacRoman
  def self.covers?(character); end
  def self.from_unicode(string); end
  def self.from_unicode_codepoints(array); end
  def self.from_utf8(string); end
  def self.to_unicode(string); end
  def self.to_unicode_codepoints(array); end
  def self.to_utf8(string); end
end
class TTFunk::Encoding::Windows1252
  def self.covers?(character); end
  def self.from_unicode(string); end
  def self.from_unicode_codepoints(array); end
  def self.from_utf8(string); end
  def self.to_unicode(string); end
  def self.to_unicode_codepoints(array); end
  def self.to_utf8(string); end
end
class TTFunk::Table
  def exists?; end
  def file; end
  def initialize(file); end
  def length; end
  def offset; end
  def parse!; end
  def raw; end
  def tag; end
  include TTFunk::Reader
end
class TTFunk::Table::Cmap < TTFunk::Table
  def parse!; end
  def self.encode(charmap, encoding); end
  def tables; end
  def unicode; end
  def version; end
end
module TTFunk::Table::Cmap::Format00
  def [](code); end
  def code_map; end
  def language; end
  def parse_cmap!; end
  def self.encode(charmap); end
  def supported?; end
end
module TTFunk::Table::Cmap::Format04
  def [](code); end
  def code_map; end
  def language; end
  def parse_cmap!; end
  def self.encode(charmap); end
  def supported?; end
end
module TTFunk::Table::Cmap::Format06
  def [](code); end
  def code_map; end
  def language; end
  def parse_cmap!; end
  def self.encode(charmap); end
  def supported?; end
end
module TTFunk::Table::Cmap::Format10
  def [](code); end
  def code_map; end
  def language; end
  def parse_cmap!; end
  def self.encode(charmap); end
  def supported?; end
end
module TTFunk::Table::Cmap::Format12
  def [](code); end
  def code_map; end
  def language; end
  def parse_cmap!; end
  def self.encode(charmap); end
  def supported?; end
end
class TTFunk::Table::Cmap::Subtable
  def [](code); end
  def encoding_id; end
  def format; end
  def initialize(file, table_start); end
  def parse_cmap!; end
  def platform_id; end
  def self.encode(charmap, encoding); end
  def supported?; end
  def unicode?; end
  include TTFunk::Reader
end
class TTFunk::Table::Glyf < TTFunk::Table
  def for(glyph_id); end
  def parse!; end
  def self.encode(glyphs, new2old, old2new); end
end
class TTFunk::Table::Glyf::Compound
  def compound?; end
  def glyph_ids; end
  def initialize(raw, x_min, y_min, x_max, y_max); end
  def raw; end
  def recode(mapping); end
  def x_max; end
  def x_min; end
  def y_max; end
  def y_min; end
  include TTFunk::Reader
end
class TTFunk::Table::Glyf::Compound::Component < Struct
  def arg1; end
  def arg1=(_); end
  def arg2; end
  def arg2=(_); end
  def flags; end
  def flags=(_); end
  def glyph_index; end
  def glyph_index=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def transform; end
  def transform=(_); end
end
class TTFunk::Table::Glyf::Simple
  def compound?; end
  def initialize(raw, number_of_contours, x_min, y_min, x_max, y_max); end
  def number_of_contours; end
  def raw; end
  def recode(mapping); end
  def x_max; end
  def x_min; end
  def y_max; end
  def y_min; end
end
class TTFunk::Table::Head < TTFunk::Table
  def checksum_adjustment; end
  def created; end
  def flags; end
  def font_direction_hint; end
  def font_revision; end
  def glyph_data_format; end
  def index_to_loc_format; end
  def lowest_rec_ppem; end
  def mac_style; end
  def magic_number; end
  def modified; end
  def parse!; end
  def self.encode(head, loca); end
  def units_per_em; end
  def version; end
  def x_max; end
  def x_min; end
  def y_max; end
  def y_min; end
end
class TTFunk::Table::Hhea < TTFunk::Table
  def advance_width_max; end
  def ascent; end
  def carot_slope_rise; end
  def carot_slope_run; end
  def descent; end
  def line_gap; end
  def metric_data_format; end
  def min_left_side_bearing; end
  def min_right_side_bearing; end
  def number_of_metrics; end
  def parse!; end
  def self.encode(hhea, hmtx); end
  def version; end
  def x_max_extent; end
end
class TTFunk::Table::Hmtx < TTFunk::Table
  def for(glyph_id); end
  def left_side_bearings; end
  def metrics; end
  def parse!; end
  def self.encode(hmtx, mapping); end
  def widths; end
end
class TTFunk::Table::Hmtx::HorizontalMetric < Struct
  def advance_width; end
  def advance_width=(_); end
  def left_side_bearing; end
  def left_side_bearing=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class TTFunk::Table::Kern < TTFunk::Table
  def add_table(format, attributes = nil); end
  def parse!; end
  def parse_version_0_tables(num_tables); end
  def parse_version_1_tables(num_tables); end
  def self.encode(kerning, mapping); end
  def tables; end
  def version; end
end
class TTFunk::Table::Kern::Format0
  def attributes; end
  def cross_stream?; end
  def horizontal?; end
  def initialize(attributes = nil); end
  def pairs; end
  def recode(mapping); end
  def vertical?; end
  include TTFunk::Reader
end
class TTFunk::Table::Loca < TTFunk::Table
  def index_of(glyph_id); end
  def offsets; end
  def parse!; end
  def self.encode(offsets); end
  def size_of(glyph_id); end
end
class TTFunk::Table::Maxp < TTFunk::Table
  def max_component_contours; end
  def max_component_depth; end
  def max_component_elements; end
  def max_component_points; end
  def max_contours; end
  def max_function_defs; end
  def max_instruction_defs; end
  def max_points; end
  def max_size_of_instructions; end
  def max_stack_elements; end
  def max_storage; end
  def max_twilight_points; end
  def max_zones; end
  def num_glyphs; end
  def parse!; end
  def self.encode(maxp, mapping); end
  def version; end
end
class TTFunk::Table::Name < TTFunk::Table
  def compatible_full; end
  def copyright; end
  def description; end
  def designer; end
  def designer_url; end
  def font_family; end
  def font_name; end
  def font_subfamily; end
  def license; end
  def license_url; end
  def manufacturer; end
  def parse!; end
  def postscript_name; end
  def preferred_family; end
  def preferred_subfamily; end
  def sample_text; end
  def self.encode(names); end
  def strings; end
  def trademark; end
  def unique_subfamily; end
  def vendor_url; end
  def version; end
end
class TTFunk::Table::Name::String < String
  def encoding_id; end
  def initialize(text, platform_id, encoding_id, language_id); end
  def language_id; end
  def platform_id; end
  def strip_extended; end
end
class TTFunk::Table::OS2 < TTFunk::Table
  def ascent; end
  def ave_char_width; end
  def break_char; end
  def cap_height; end
  def char_range; end
  def code_page_range; end
  def default_char; end
  def descent; end
  def family_class; end
  def first_char_index; end
  def last_char_index; end
  def line_gap; end
  def max_context; end
  def panose; end
  def parse!; end
  def selection; end
  def tag; end
  def type; end
  def vendor_id; end
  def version; end
  def weight_class; end
  def width_class; end
  def win_ascent; end
  def win_descent; end
  def x_height; end
  def y_strikeout_position; end
  def y_strikeout_size; end
  def y_subscript_x_offset; end
  def y_subscript_x_size; end
  def y_subscript_y_offset; end
  def y_subscript_y_size; end
  def y_superscript_x_offset; end
  def y_superscript_x_size; end
  def y_superscript_y_offset; end
  def y_superscript_y_size; end
end
class TTFunk::Table::Post < TTFunk::Table
  def fixed_pitch; end
  def fixed_pitch?; end
  def format; end
  def glyph_for(code); end
  def italic_angle; end
  def max_mem_type1; end
  def max_mem_type42; end
  def min_mem_type1; end
  def min_mem_type42; end
  def parse!; end
  def parse_format!; end
  def recode(mapping); end
  def self.encode(post, mapping); end
  def subtable; end
  def underline_position; end
  def underline_thickness; end
end
module TTFunk::Table::Post::Format10
  def glyph_for(code); end
  def parse_format!; end
end
module TTFunk::Table::Post::Format20
  def glyph_for(code); end
  def parse_format!; end
  include TTFunk::Table::Post::Format10
end
module TTFunk::Table::Post::Format30
  def glyph_for(code); end
  def parse_format!; end
end
module TTFunk::Table::Post::Format40
  def glyph_for(code); end
  def parse_format!; end
end
class TTFunk::Table::Sbix < TTFunk::Table
  def all_bitmap_data_for(glyph_id); end
  def bitmap_data_for(glyph_id, strike_index); end
  def flags; end
  def num_strikes; end
  def parse!; end
  def strikes; end
  def version; end
end
class TTFunk::Table::Sbix::BitmapData < Struct
  def data; end
  def data=(_); end
  def ppem; end
  def ppem=(_); end
  def resolution; end
  def resolution=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def type; end
  def type=(_); end
  def x; end
  def x=(_); end
  def y; end
  def y=(_); end
end
class TTFunk::File
  def ascent; end
  def bbox; end
  def cmap; end
  def contents; end
  def descent; end
  def directory; end
  def directory_info(tag); end
  def glyph_locations; end
  def glyph_outlines; end
  def header; end
  def horizontal_header; end
  def horizontal_metrics; end
  def initialize(contents); end
  def kerning; end
  def line_gap; end
  def maximum_profile; end
  def name; end
  def os2; end
  def postscript; end
  def sbix; end
  def self.from_dfont(file, which = nil); end
  def self.open(io_or_path); end
  def self.verify_and_open(io_or_path); end
end
class TTFunk::Table::Simple < TTFunk::Table
  def initialize(file, tag); end
  def tag; end
end
module TTFunk::Subset
  def self.for(original, encoding); end
end
class TTFunk::Subset::Base
  def checksum(data); end
  def collect_glyphs(glyph_ids); end
  def encode(options = nil); end
  def initialize(original); end
  def original; end
  def to_unicode_map; end
  def unicode?; end
  def unicode_cmap; end
end
class TTFunk::Subset::Unicode < TTFunk::Subset::Base
  def covers?(character); end
  def from_unicode(character); end
  def includes?(character); end
  def initialize(original); end
  def new_cmap_table(options); end
  def original_glyph_ids; end
  def to_unicode_map; end
  def unicode?; end
  def use(character); end
end
class TTFunk::Subset::Unicode8Bit < TTFunk::Subset::Base
  def covers?(character); end
  def from_unicode(character); end
  def includes?(character); end
  def initialize(original); end
  def new_cmap_table(options); end
  def original_glyph_ids; end
  def to_unicode_map; end
  def unicode?; end
  def use(character); end
end
class TTFunk::Subset::MacRoman < TTFunk::Subset::Base
  def covers?(character); end
  def from_unicode(character); end
  def includes?(character); end
  def initialize(original); end
  def new_cmap_table(options); end
  def original_glyph_ids; end
  def to_unicode_map; end
  def use(character); end
end
class TTFunk::Subset::Windows1252 < TTFunk::Subset::Base
  def covers?(character); end
  def from_unicode(character); end
  def includes?(character); end
  def initialize(original); end
  def new_cmap_table(options); end
  def original_glyph_ids; end
  def to_unicode_map; end
  def use(character); end
end
class TTFunk::SubsetCollection
  def [](subset); end
  def encode(characters); end
  def initialize(original); end
  def use(characters); end
end
