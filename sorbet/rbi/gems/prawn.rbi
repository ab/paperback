# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/prawn/all/prawn.rbi
#
# prawn-1.3.0
module Prawn
  def debug; end
  def debug=(arg0); end
  def self.image_handler; end
  def verify_options(accepted, actual); end
  extend Prawn
end
module Prawn::Errors
end
class Prawn::Errors::InvalidTableSpan < StandardError
end
class Prawn::Errors::NotOnPage < StandardError
end
class Prawn::Errors::UnknownFont < StandardError
end
class Prawn::Errors::CannotFit < StandardError
end
class Prawn::Errors::CannotGroup < StandardError
end
class Prawn::Errors::IncompatibleStringEncoding < StandardError
end
class Prawn::Errors::UnknownOption < StandardError
end
class Prawn::Errors::UnsupportedImageType < StandardError
end
class Prawn::Errors::NameTaken < StandardError
end
class Prawn::Errors::InvalidName < StandardError
end
class Prawn::Errors::UndefinedObjectName < StandardError
end
class Prawn::Errors::RequiredOption < StandardError
end
class Prawn::Errors::UnknownOutlineTitle < StandardError
end
class Prawn::Errors::BlockRequired < StandardError
end
class Prawn::Errors::InvalidGraphicsPath < StandardError
end
class Prawn::Errors::UnrecognizedTableContent < StandardError
end
class Prawn::SynchronizedCache
  def [](key); end
  def []=(key, value); end
  def initialize; end
end
class Prawn::ThreadLocalCache
  def [](key); end
  def []=(key, value); end
  def initialize; end
end
module Prawn::Text
  def draw_indented_formatted_line(string, options); end
  def draw_remaining_formatted_text_on_new_pages(remaining_text, options); end
  def draw_text!(text, options); end
  def draw_text(text, options); end
  def fill_formatted_text_box(text, options); end
  def formatted_text(array, options = nil); end
  def height_of(string, options = nil); end
  def height_of_formatted(array, options = nil); end
  def inspect_options_for_draw_text(options); end
  def inspect_options_for_text(options); end
  def merge_text_box_positioning_options(options); end
  def move_text_position(dy); end
  def process_final_gap_option(options); end
  def process_indent_paragraphs_option(options); end
  def text(string, options = nil); end
  def text_box(string, options = nil); end
  include PDF::Core::Text
  include Prawn::Text::Formatted
end
module Prawn::Text::Formatted
  def formatted_text_box(array, options = nil); end
end
class Prawn::Text::Formatted::LineWrap
  def add_fragment_to_line(fragment); end
  def append_char(char, font); end
  def apply_font_settings_and_add_fragment_to_line(fragment); end
  def break_chars; end
  def determine_whether_to_pull_preceding_fragment_to_join_this_one(current_fragment); end
  def empty_line?(fragment); end
  def end_of_the_line_reached(segment); end
  def first_fragment_on_this_line?(fragment); end
  def fragment_begins_with_breakable?(fragment); end
  def fragment_finished(fragment); end
  def hyphen; end
  def initialize_line(options); end
  def is_next_string_newline?; end
  def line_empty?; end
  def line_finished?; end
  def paragraph_finished?; end
  def previous_fragment_ended_with_breakable?; end
  def remember_this_fragment_for_backward_looking_ops; end
  def scan_pattern; end
  def set_soft_hyphen_and_zero_width_space; end
  def soft_hyphen; end
  def space_count; end
  def tokenize(fragment); end
  def update_line_status_based_on_last_output; end
  def update_output_based_on_last_fragment(fragment, normalized_soft_hyphen = nil); end
  def whitespace; end
  def width; end
  def word_division_scan_pattern; end
  def wrap_by_char(segment); end
  def wrap_line(options); end
  def zero_width_space; end
end
class Prawn::Text::Formatted::Arranger
  def apply_color_and_font_settings(fragment, &block); end
  def apply_font_settings(fragment = nil, &block); end
  def apply_font_size(size, styles); end
  def consumed; end
  def consumed=(arg0); end
  def current_format_state; end
  def finalize_line; end
  def finished?; end
  def font_style(styles); end
  def format_array=(array); end
  def fragments; end
  def initialize(document, options = nil); end
  def initialize_line; end
  def line; end
  def line_width; end
  def load_previous_format_state; end
  def max_ascender; end
  def max_descender; end
  def max_line_height; end
  def next_string; end
  def omit_trailing_whitespace_from_line_width; end
  def preview_next_string; end
  def repack_unretrieved; end
  def retrieve_fragment; end
  def set_fragment_measurements(fragment); end
  def set_line_measurement_maximums(fragment); end
  def space_count; end
  def subscript?(styles); end
  def superscript?(styles); end
  def unconsumed; end
  def update_last_string(printed, unprinted, normalized_soft_hyphen = nil); end
end
module Prawn::Text::Formatted::Wrap
  def enough_height_for_this_line?; end
  def format_and_draw_fragment(fragment, accumulated_width, line_width, word_spacing); end
  def initialize(array, options); end
  def initialize_wrap(array); end
  def print_line; end
  def word_spacing_for_this_line; end
  def wrap(array); end
end
class Prawn::Text::Formatted::Box
  def analyze_glyphs_for_fallback_font_support(hash); end
  def ascender; end
  def at; end
  def available_width; end
  def default_height; end
  def descender; end
  def draw_fragment(fragment, accumulated_width = nil, line_width = nil, word_spacing = nil); end
  def draw_fragment_overlay_anchor(fragment); end
  def draw_fragment_overlay_link(fragment); end
  def draw_fragment_overlay_local(fragment); end
  def draw_fragment_overlay_styles(fragment); end
  def draw_fragment_overlays(fragment); end
  def draw_fragment_underlays(fragment); end
  def everything_printed?; end
  def find_font_for_this_glyph(char, current_font, fallback_fonts); end
  def form_fragments_from_like_font_glyph_pairs(font_glyph_pairs, hash); end
  def height; end
  def initialize(formatted_text, options = nil); end
  def leading; end
  def line_gap; end
  def line_height; end
  def move_baseline_down; end
  def normalize_encoding; end
  def normalized_text(flags); end
  def nothing_printed?; end
  def original_text; end
  def original_text=(formatted_text); end
  def process_fallback_fonts(formatted_text); end
  def process_options; end
  def process_vertical_alignment(text); end
  def render(flags = nil); end
  def render_rotated(text); end
  def self.extensions; end
  def self.inherited(base); end
  def shrink_to_fit(text); end
  def text; end
  def valid_options; end
  include Prawn::Text::Formatted::Wrap
end
class Prawn::Text::Formatted::Parser
  def self.array_from_tokens(tokens); end
  def self.array_paragraphs(array); end
  def self.format(string, *args); end
  def self.to_string(array); end
end
class Prawn::Text::Formatted::Fragment
  def absolute_bottom; end
  def absolute_bottom_left; end
  def absolute_bottom_right; end
  def absolute_bounding_box; end
  def absolute_left; end
  def absolute_right; end
  def absolute_top; end
  def absolute_top_left; end
  def absolute_top_right; end
  def anchor; end
  def ascender; end
  def ascender=(arg0); end
  def baseline; end
  def baseline=(arg0); end
  def bottom; end
  def bottom_left; end
  def bottom_right; end
  def bounding_box; end
  def callback_objects; end
  def character_spacing; end
  def color; end
  def default_direction=(direction); end
  def descender; end
  def descender=(arg0); end
  def direction; end
  def exclude_trailing_white_space?; end
  def font; end
  def format_state; end
  def height; end
  def include_trailing_white_space!; end
  def initialize(text, format_state, document); end
  def left; end
  def left=(arg0); end
  def line_height; end
  def line_height=(arg0); end
  def link; end
  def local; end
  def normalized_soft_hyphen; end
  def process_soft_hyphens(string); end
  def process_text(text); end
  def right; end
  def size; end
  def soft_hyphens_need_processing?(string); end
  def space_count; end
  def strikethrough_points; end
  def strip_zero_width_spaces(string); end
  def styles; end
  def subscript?; end
  def superscript?; end
  def text; end
  def top; end
  def top_left; end
  def top_right; end
  def underline_points; end
  def width; end
  def width=(arg0); end
  def word_spacing; end
  def word_spacing=(arg0); end
  def y_offset; end
end
class Prawn::Text::Box < Prawn::Text::Formatted::Box
  def initialize(string, options = nil); end
  def render(flags = nil); end
end
module Prawn::Graphics
  def circle(center, radius); end
  def close_and_stroke; end
  def close_path; end
  def current_line_width; end
  def current_line_width=(width); end
  def curve(origin, dest, options = nil); end
  def curve_to(dest, options = nil); end
  def degree_to_rad(angle); end
  def ellipse(point, r1, r2 = nil); end
  def fill(options = nil); end
  def fill_and_stroke(options = nil); end
  def fill_and_stroke_circle(*args); end
  def fill_and_stroke_circle_at(*args); end
  def fill_and_stroke_curve(*args); end
  def fill_and_stroke_curve_to(*args); end
  def fill_and_stroke_ellipse(*args); end
  def fill_and_stroke_ellipse_at(*args); end
  def fill_and_stroke_horizontal_line(*args); end
  def fill_and_stroke_horizontal_rule(*args); end
  def fill_and_stroke_line(*args); end
  def fill_and_stroke_line_to(*args); end
  def fill_and_stroke_polygon(*args); end
  def fill_and_stroke_rectangle(*args); end
  def fill_and_stroke_rounded_polygon(*args); end
  def fill_and_stroke_rounded_rectangle(*args); end
  def fill_and_stroke_rounded_vertex(*args); end
  def fill_and_stroke_vertical_line(*args); end
  def fill_circle(*args); end
  def fill_circle_at(*args); end
  def fill_curve(*args); end
  def fill_curve_to(*args); end
  def fill_ellipse(*args); end
  def fill_ellipse_at(*args); end
  def fill_horizontal_line(*args); end
  def fill_horizontal_rule(*args); end
  def fill_line(*args); end
  def fill_line_to(*args); end
  def fill_polygon(*args); end
  def fill_rectangle(*args); end
  def fill_rounded_polygon(*args); end
  def fill_rounded_rectangle(*args); end
  def fill_rounded_vertex(*args); end
  def fill_vertical_line(*args); end
  def horizontal_line(x1, x2, options = nil); end
  def horizontal_rule; end
  def line(*points); end
  def line_to(*point); end
  def line_width(width = nil); end
  def line_width=(width); end
  def map_to_absolute!(point); end
  def map_to_absolute(*point); end
  def move_to(*point); end
  def point_on_line(distance_from_end, *points); end
  def polygon(*points); end
  def rectangle(point, width, height); end
  def rounded_polygon(radius, *points); end
  def rounded_rectangle(point, width, height, radius); end
  def rounded_vertex(radius, *points); end
  def stroke; end
  def stroke_axis(options = nil); end
  def stroke_bounds; end
  def stroke_circle(*args); end
  def stroke_circle_at(*args); end
  def stroke_curve(*args); end
  def stroke_curve_to(*args); end
  def stroke_ellipse(*args); end
  def stroke_ellipse_at(*args); end
  def stroke_horizontal_line(*args); end
  def stroke_horizontal_rule(*args); end
  def stroke_line(*args); end
  def stroke_line_to(*args); end
  def stroke_polygon(*args); end
  def stroke_rectangle(*args); end
  def stroke_rounded_polygon(*args); end
  def stroke_rounded_rectangle(*args); end
  def stroke_rounded_vertex(*args); end
  def stroke_vertical_line(*args); end
  def vertical_line(y1, y2, params); end
  def write_line_width; end
  include Prawn::Graphics::CapStyle
  include Prawn::Graphics::Color
  include Prawn::Graphics::Dash
  include Prawn::Graphics::JoinStyle
  include Prawn::Graphics::Patterns
  include Prawn::Graphics::Transformation
  include Prawn::Graphics::Transparency
end
module Prawn::Graphics::Color
  def color_space(color); end
  def color_to_s(color); end
  def color_type(color); end
  def current_color_space(type); end
  def current_fill_color; end
  def current_fill_color=(color); end
  def current_stroke_color; end
  def current_stroke_color=(color); end
  def fill_color(*color); end
  def fill_color=(*color); end
  def hex2rgb(hex); end
  def normalize_color(color); end
  def process_color(*color); end
  def rgb2hex(rgb); end
  def self.hex2rgb(hex); end
  def self.rgb2hex(rgb); end
  def set_color(type, color, options = nil); end
  def set_color_space(type, color_space); end
  def set_current_color_space(color_space, type); end
  def set_fill_color(color = nil); end
  def set_stroke_color(color = nil); end
  def stroke_color(*color); end
  def stroke_color=(*color); end
  def update_colors; end
  def write_color(color, operator); end
  def write_fill_color; end
  def write_stroke_color; end
end
module Prawn::Graphics::Dash
  def current_dash_state; end
  def current_dash_state=(dash_options); end
  def dash(length = nil, options = nil); end
  def dash=(length = nil, options = nil); end
  def dash_setting; end
  def dashed?; end
  def undash; end
  def undashed_setting; end
  def write_stroke_dash; end
end
module Prawn::Graphics::CapStyle
  def cap_style(style = nil); end
  def cap_style=(style = nil); end
  def current_cap_style; end
  def current_cap_style=(style); end
  def write_stroke_cap_style; end
end
module Prawn::Graphics::JoinStyle
  def current_join_style; end
  def current_join_style=(style); end
  def join_style(style = nil); end
  def join_style=(style = nil); end
  def write_stroke_join_style; end
end
module Prawn::Graphics::Transparency
  def next_opacity_dictionary_id; end
  def opacity_dictionary_name(opacity, stroke_opacity); end
  def opacity_dictionary_registry; end
  def transparent(opacity, stroke_opacity = nil, &block); end
end
module Prawn::Graphics::Transformation
  def rotate(angle, options = nil, &block); end
  def scale(factor, options = nil, &block); end
  def transformation_matrix(a, b, c, d, e, f); end
  def translate(x, y, &block); end
end
module Prawn::Graphics::Patterns
  def fill_gradient(*args); end
  def gradient(*args); end
  def gradient_registry; end
  def gradient_registry_key(gradient); end
  def set_gradient(type, *grad); end
  def stroke_gradient(*args); end
end
module Prawn::Images
  def build_image_object(file); end
  def determine_y_with_page_flow(h); end
  def embed_image(pdf_obj, info, options); end
  def image(file, options = nil); end
  def image_position(w, h, options); end
  def image_registry; end
  def next_image_id; end
  def overruns_page?(h); end
  def verify_and_open_image(io_or_path); end
end
class Prawn::Images::Image
  def calc_image_dimensions(options); end
end
class Prawn::Images::JPG < Prawn::Images::Image
  def bits; end
  def build_pdf_object(document); end
  def channels; end
  def height; end
  def initialize(data); end
  def scaled_height; end
  def scaled_height=(arg0); end
  def scaled_width; end
  def scaled_width=(arg0); end
  def self.can_render?(image_blob); end
  def width; end
end
class Prawn::Images::PNG < Prawn::Images::Image
  def alpha_channel; end
  def alpha_channel?; end
  def bits; end
  def build_pdf_object(document); end
  def color_type; end
  def colors; end
  def compression_method; end
  def filter_method; end
  def height; end
  def img_data; end
  def initialize(data); end
  def interlace_method; end
  def min_pdf_version; end
  def palette; end
  def scaled_height; end
  def scaled_height=(arg0); end
  def scaled_width; end
  def scaled_width=(arg0); end
  def self.can_render?(image_blob); end
  def split_alpha_channel!; end
  def split_image_data; end
  def transparency; end
  def width; end
end
module Prawn::Stamp
  def create_stamp(name, &block); end
  def create_stamp_dictionary(name); end
  def freeze_stamp_graphics; end
  def next_stamp_dictionary_id; end
  def stamp(name); end
  def stamp_at(name, point); end
  def stamp_dictionary(name); end
  def stamp_dictionary_registry; end
end
module Prawn::SoftMask
  def soft_mask(&block); end
  def soft_mask_registry; end
end
class Arcfour
  def encrypt(string); end
  def initialize(key); end
  def key_byte; end
end
class Prawn::Document
  def apply_margin_options(options); end
  def bounding_box(pt, *args, &block); end
  def bounds; end
  def bounds=(bounding_box); end
  def canvas(&block); end
  def column_box(*args, &block); end
  def cursor; end
  def define_grid(options = nil); end
  def find_font(name, options = nil); end
  def float; end
  def font(name = nil, options = nil); end
  def font_families; end
  def font_metric_cache; end
  def font_registry; end
  def font_size(points = nil); end
  def font_size=(size); end
  def generate_margin_box; end
  def go_to_page(k); end
  def grid(*args); end
  def group(*a, &b); end
  def indent(left, right = nil, &block); end
  def init_bounding_box(user_block, options = nil, &init_block); end
  def init_column_box(user_block, options = nil, &init_block); end
  def initialize(options = nil, &block); end
  def initialize_first_page(options); end
  def margin_box; end
  def margin_box=(arg0); end
  def margins; end
  def mask(*fields); end
  def move_cursor_to(new_y); end
  def move_down(n); end
  def move_up(n); end
  def multi_box(b1, b2); end
  def number_pages(string, options = nil); end
  def outline; end
  def pad(y); end
  def pad_bottom(y); end
  def pad_top(y); end
  def page; end
  def page_count; end
  def page_match?(page_filter, page_number); end
  def page_number; end
  def page_number=(arg0); end
  def reference_bounds; end
  def render(*a, &b); end
  def render_file(filename); end
  def repeat(page_filter, options = nil, &block); end
  def repeaters; end
  def save_font; end
  def self.extensions; end
  def self.generate(filename, options = nil, &block); end
  def self.inherited(base); end
  def set_font(font, size = nil); end
  def single_box(i, j); end
  def span(width, options = nil); end
  def start_new_page(options = nil); end
  def state; end
  def text_formatter; end
  def text_formatter=(arg0); end
  def transaction; end
  def use_graphic_settings(override_settings = nil); end
  def width_of(string, options = nil); end
  def width_of_inline_formatted_string(string, options = nil); end
  def width_of_string(string, options = nil); end
  def y; end
  def y=(new_y); end
  include PDF::Core::Annotations
  include PDF::Core::Destinations
  include Prawn::Document::Internals
  include Prawn::Document::Security
  include Prawn::Graphics
  include Prawn::Images
  include Prawn::SoftMask
  include Prawn::Stamp
  include Prawn::Text
end
module Prawn::Document::Security
  def encrypt_document(options = nil); end
  def encryption_dictionary; end
  def owner_password_hash; end
  def pad_password(password); end
  def permissions=(perms = nil); end
  def permissions_value; end
  def self.encrypt_string(str, key, id, gen); end
  def user_encryption_key; end
  def user_password_hash; end
end
module PDF
end
module PDF::Core
  def EncryptedPdfObject(obj, key, id, gen, in_content_stream = nil); end
  def self.EncryptedPdfObject(obj, key, id, gen, in_content_stream = nil); end
end
class PDF::Core::Stream
  def encrypted_object(key, id, gen); end
end
class PDF::Core::Reference
  def encrypted_object(key); end
end
class Prawn::Document::BoundingBox
  def absolute_bottom; end
  def absolute_bottom_left; end
  def absolute_bottom_right; end
  def absolute_left; end
  def absolute_right; end
  def absolute_top; end
  def absolute_top_left; end
  def absolute_top_right; end
  def add_left_padding(left_padding); end
  def add_right_padding(right_padding); end
  def anchor; end
  def bottom; end
  def bottom_left; end
  def bottom_right; end
  def deep_copy; end
  def document; end
  def height; end
  def indent(left_padding, right_padding = nil, &block); end
  def initialize(document, parent, point, options = nil); end
  def left; end
  def left_side; end
  def move_past_bottom; end
  def parent; end
  def reference_bounds; end
  def right; end
  def right_side; end
  def self.restore_deep_copy(bounds, document); end
  def stretchy?; end
  def subtract_left_padding(left_padding); end
  def subtract_right_padding(right_padding); end
  def top; end
  def top_left; end
  def top_right; end
  def total_left_padding; end
  def total_right_padding; end
  def update_height; end
  def width; end
end
class Prawn::Document::ColumnBox < Prawn::Document::BoundingBox
  def add_left_padding(left_padding); end
  def add_right_padding(right_padding); end
  def bare_column_width; end
  def initialize(document, parent, point, options = nil); end
  def left; end
  def left_side; end
  def move_past_bottom; end
  def right; end
  def right_side; end
  def subtract_left_padding(left_padding); end
  def subtract_right_padding(right_padding); end
  def width; end
  def width_of_column; end
end
module Prawn::Document::Internals
  def add_content(*args, &block); end
  def compression_enabled?(*args, &block); end
  def deref(*args, &block); end
  def graphic_state(*args, &block); end
  def names(*args, &block); end
  def ref!(*args, &block); end
  def ref(*args, &block); end
  def renderer; end
  def restore_graphics_state(*args, &block); end
  def save_graphics_state(*args, &block); end
  extend Forwardable
end
module Prawn::Encoding
end
class Prawn::Encoding::WinAnsi
  def [](codepoint); end
  def initialize; end
  def load_mapping; end
  def self.mapping; end
end
class Prawn::Font
  def add_to_current_page(subset); end
  def ascender; end
  def descender; end
  def eql?(other); end
  def family; end
  def generate_unique_id; end
  def hash; end
  def height; end
  def height_at(size); end
  def identifier_for(subset); end
  def initialize(document, name, options = nil); end
  def inspect; end
  def line_gap; end
  def name; end
  def normalize_encoding!(str); end
  def normalize_encoding(string); end
  def options; end
  def self.font_format(src, options); end
  def self.load(document, src, options = nil); end
  def size; end
end
class Prawn::Font::AFM < Prawn::Font
  def attributes; end
  def bbox; end
  def character_count(str); end
  def compute_width_of(string, options = nil); end
  def encode_text(text, options = nil); end
  def find_font(file); end
  def glyph_present?(char); end
  def has_kerning_data?; end
  def initialize(document, name, options = nil); end
  def kern(string); end
  def normalize_encoding(text); end
  def parse_afm(file_name); end
  def parse_generic_afm_attribute(line, hash); end
  def register(subset); end
  def self.metrics_path; end
  def symbolic?; end
  def unicode?; end
  def unscaled_width_of(string); end
end
class Prawn::Font::TTF < Prawn::Font
  def basename; end
  def bbox; end
  def cap_height; end
  def character_count(str); end
  def character_width_by_code(code); end
  def cid_to_gid_map; end
  def cmap; end
  def compute_width_of(string, options = nil); end
  def embed(reference, subset); end
  def encode_text(text, options = nil); end
  def family_class; end
  def glyph_present?(char); end
  def has_kerning_data?; end
  def hmtx; end
  def initialize(document, name, options = nil); end
  def italic_angle; end
  def kern(string); end
  def kern_pairs_table; end
  def normalize_encoding(text); end
  def pdf_flags; end
  def read_ttf_file; end
  def register(subset); end
  def scale_factor; end
  def script?; end
  def serif?; end
  def stemV; end
  def subsets; end
  def ttf; end
  def unicode?; end
  def x_height; end
end
class Prawn::Font::DFont < Prawn::Font::TTF
  def read_ttf_file; end
  def self.font_count(file); end
  def self.named_fonts(file); end
end
class Prawn::FontMetricCache
  def initialize(document); end
  def width_of(string, options); end
end
class Prawn::FontMetricCache::CacheEntry < Struct
  def font; end
  def font=(_); end
  def options; end
  def options=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def string; end
  def string=(_); end
end
module Prawn::Measurements
  def cm2mm(cm); end
  def cm2pt(cm); end
  def dm2mm(dm); end
  def dm2pt(dm); end
  def ft2in(ft); end
  def ft2pt(ft); end
  def in2pt(inch); end
  def m2mm(m); end
  def m2pt(m); end
  def mm2pt(mm); end
  def pt2mm(pt); end
  def pt2pt(pt); end
  def yd2in(yd); end
  def yd2pt(yd); end
end
class Prawn::Repeater
  def initialize(document, page_filter, dynamic = nil, &block); end
  def match?(page_number); end
  def name; end
  def run(page_number); end
  def self.count; end
  def self.count=(arg0); end
end
class Prawn::Outline
  def add_outline_item(title, options, &block); end
  def add_subsection_to(title, position = nil, &block); end
  def adjust_relations(nxt, last); end
  def create_outline_item(title, options); end
  def define(&block); end
  def document; end
  def document=(arg0); end
  def increase_count; end
  def initialize(document); end
  def insert_section(nxt, &block); end
  def insert_section_after(title, &block); end
  def items; end
  def items=(arg0); end
  def page(options = nil); end
  def page_number; end
  def parent; end
  def parent=(arg0); end
  def prev; end
  def prev=(arg0); end
  def reset_parent(outline_item); end
  def reset_root_positioning; end
  def root; end
  def section(title, options = nil, &block); end
  def set_relations(outline_item); end
  def set_variables_for_block(outline_item, block); end
  def update(&block); end
end
class Prawn::Document::Grid
  def column_gutter; end
  def column_width; end
  def columns; end
  def gutter; end
  def initialize(pdf, options = nil); end
  def pdf; end
  def row_gutter; end
  def row_height; end
  def rows; end
  def set_gutter(options); end
  def show_all(color = nil); end
  def subdivide(total, num, gutter); end
end
class Prawn::Document::GridBox
  def bottom; end
  def bottom_left; end
  def bottom_right; end
  def bounding_box(&blk); end
  def grid; end
  def gutter; end
  def height; end
  def initialize(pdf, i, j); end
  def left; end
  def name; end
  def pdf; end
  def right; end
  def show(grid_color = nil); end
  def top; end
  def top_left; end
  def top_right; end
  def total_height; end
  def width; end
end
class Prawn::Document::MultiBox < Prawn::Document::GridBox
  def bottom; end
  def bottom_box; end
  def gutter; end
  def height; end
  def initialize(pdf, b1, b2); end
  def left; end
  def left_box; end
  def name; end
  def right; end
  def right_box; end
  def top; end
  def top_box; end
  def total_height; end
  def width; end
end
module Prawn::View
  def document; end
  def method_missing(m, *a, &b); end
  def save_as(filename); end
  def update(&b); end
end
class Prawn::ImageHandler
  def find(image_blob); end
  def initialize; end
  def register!(handler); end
  def register(handler); end
  def unregister(handler); end
end
module Prawn::Configurable
  def C(*args); end
  def configuration(*args); end
end
